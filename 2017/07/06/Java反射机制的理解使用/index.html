<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Java反射机制的理解使用 · Beaven's Blog</title><meta name="description" content="Java反射机制的理解使用 - Beaven Wang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicona.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Beaven's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/beaven-wang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Java反射机制的理解使用</h1><div class="post-info">Jul 6, 2017</div><div class="post-content"><p>一、Java反射机制的理解</p>
<p>反射（Reflection）是Java语言中的一项重要功能，通过反射API可以获取程序在运行时Java类的内部结构，实现对Java代码的动态操作，在实际项目开发中其多要用于框架的构建，一般开发中较少使用，但研究理解是非常必要的。<br><a id="more"></a><br>二、Java反射机制的使用</p>
<p>反射机制的实现主要依赖于Class类和java.lang.reflect.*包中提供的类。通过这些类可以实现对象的创建，类方法的访问等。</p>
<p>（一）Class对象的获取</p>
<p>Class类的构造方法为私有方法，只能由jvm虚拟机在运行时生成，用来保存实例对象的相关信息。获得一个实例对象对应的Class对象，主要有三种方法：</p>
<ol>
<li><p>通过实例变量的getClass()方法，这种方法是获取效率最高和最安全的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Test test = <span class="keyword">new</span> Test();</div><div class="line">Class cls = test.getClass();</div></pre></td></tr></table></figure>
</li>
<li><p>通过Class.forName()静态方法获取，这种方法是常用的一种方法，它通过输入的类名查找得到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class t = Class.forName(<span class="string">"java.lang.Thread"</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>直接给出类文件的Class。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class cls = Test.class;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>（二）Class对象的使用</p>
<ol>
<li><p>构造方法的获取和使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * getConstructors可以获取声明为public的构造方法的集合，</div><div class="line"> * getDeclaredConstructors()方法获取所有的构造方法集合</div><div class="line"> */</div><div class="line">Constructor[] constructors = cls.getConstructors();</div><div class="line"><span class="comment">// 根据构造方法参数的类型获取对应的构造方法</span></div><div class="line">Constructor constructor = cls.getConstructor(String.class);</div><div class="line"></div><div class="line"><span class="keyword">for</span>(Constructor con:constructors)&#123;</div><div class="line">  <span class="comment">// 构造方法的名称</span></div><div class="line">  String name = con.getName();</div><div class="line">  <span class="comment">// 构造方法的参数类型</span></div><div class="line">  Class[] type = con.getParameterTypes();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 创建新的实例</span></div><div class="line">Object obj = constructor.newInstance();</div></pre></td></tr></table></figure>
</li>
<li><p>字段获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 获取public字段集合</div><div class="line"> * getDeclaredFields()获取所有的字段</div><div class="line"> */</div><div class="line">Field[] fields = cls.getFields();</div><div class="line"><span class="comment">// 字段名称</span></div><div class="line">String name = field.getName();</div><div class="line"><span class="comment">// 字段类型</span></div><div class="line">Class type = field.getType();</div><div class="line"><span class="comment">// 获取静态字段的值</span></div><div class="line">Object obj = field.get(Object);</div></pre></td></tr></table></figure>
</li>
<li><p>方法获取和执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 获取该类的所有方法，包括父类的方法</div><div class="line"> * getDeclaredMethods()获取该类的方法，不包括父类方法</div><div class="line"> */</div><div class="line">Method[] methods = cls.getMethods();</div><div class="line"><span class="comment">// 方法返回值类型</span></div><div class="line">Class retType = method.getReturnType();</div><div class="line"><span class="comment">// 方法名称</span></div><div class="line">String name = method.getName();</div><div class="line"><span class="comment">// 方法类型</span></div><div class="line">String modifiers = Modifier.toString(method.getModifiers());</div><div class="line"><span class="comment">// 方法参数类型</span></div><div class="line">Class[] paramTypes = method.getParameterTypes();</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 调用获取到的方法执行</div><div class="line"> * one:对象的实例</div><div class="line"> * two:方法参数的集合</div><div class="line"> */</div><div class="line">method.invoke(one,two);</div></pre></td></tr></table></figure>
</li>
<li><p>对类的私有域和方法的使用</p>
<p>类中的私有构造函数、方法和字段，通过相关的方法都可以获取到，但是在使用时确是禁止的，会抛出IllegalAccessException的异常。这是因为反射行为默认是受到Java访问的限制的，如果需要突破限制去访问控制，就需要调用Constructor、Method和Field的公共超类方法setAccessible()，设置为true时反射进制运行时会屏蔽Java语言的访问时检查。</p>
<p>在实际开发中，有时需要对隐藏的API进行使用时，通过这种机制就可以达到我们的目的。</p>
</li>
</ol>
<p>反射机制的功能十分强大，在运行时可以获取类的结构，分析对象，调用任意的方法。但是由于反射的运行都是在运行时，在编译器会错过很多的检查，不规范的使用反射会提高程序的出错率。而且其运行时需要遍历搜寻的特点，使得使用反射执行方法的速度要慢于直接调用方法。所以一般情况下，应根据实际情况尽量减少使用反射。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/06/19/Android使用Retrofit进行SOAP通信/" class="next">下一篇</a></div><div class="copyright"><p>© 2017 <a href="http://yoursite.com">Beaven Wang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>